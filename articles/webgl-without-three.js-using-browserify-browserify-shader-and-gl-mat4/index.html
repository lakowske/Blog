<html>
<head>
<title>WebGL without Three.js using Browserify, Browserify-shader and gl-mat4</title>
<link rel="stylesheet" type="text/css" href="/static/style/style.css">
<link rel="stylesheet" type="text/css" href="node_modules/prismjs-package/prism.css">
</head>
<body>
  <h1>WebGL without Three.js using Browserify, Browserify-shader and gl-mat4</h1>
  <h3>Posted by: <a href="http://sethlakowske.com">Seth Lakowske</a></h3>
  <h4>Published: <time pubdate="pubdate">2015-09-22</time></h4>

  <p>
    When writing WebGL software, resorting to three.js to draw simple
    scenes may not be necessary.  Three.js is a nice comprehensive
    library.  It has scene graphing, modeling, lighting, fog and many more functions.
    But when most of these are unneeded, pare down with Browserify and a few supporting
    modules.  The result is a smaller library with only the required code.
  <p>

  <p>
    <H2>Install Browserify</H2>
    
    To get started, install Browserify.  Browserify will combine
    your source files and their dependencies into one bundle,
    including the GLSL shaders!
    I recommend watchify too.  It automatically runs
    Browserify when source files change, so there isn't a manual compile
    step to load changes to the browser.
  </p>
  <p>
    Install browserify and watchify globally with the -g switch to run
    them on any future project.

<pre><code class="language-bash">sudo npm install browserify -g
sudo npm install watchify -g</code></pre>

  </p>

  <p>
    <H2>Init the project</H2>
    Create a project directory and run <code>npm init</code> to
    create a package.json.  This file defines project dependencies.

<pre><code class="language-bash">mkdir 3dify
cd 3dify
npm init</code></pre>
  </p>

  <p>
    Now define dependencies.<br><br>  Browserify-shader is a development dependency
    that allow you to include a shader using node-style require
    statements.  glmat-4 is a matrix library useful for doing 3d math
    (linear algebra).

<pre><code class="language-bash">npm install browserify-shader --save-dev
npm install glmat-4 --save</code></pre>
  </p>


  <H2>Draw a Rotating Triangle using gl-mat4</H2>
  We'll fill in index.html, index.js, fragment.c and vertex.c with code
  necessary to draw a rotating triangle.  This code is sufficient to draw a simple scene.


  <p>
  <H3>index.html</H3>
  index.html is an extremely simple file including only the output
  from browserify, in this case bundle.js. <br>

  <pre data-src="index.html" class="langauge-markup">
    <code id="sample" class="language-markup">
  </code></pre>
  </p>
  <H3>index.js</H3>
  Notice the glsl files, vertex.c and fragment.c, required at the top
  of the script.  Our browserify-shader dependency provides this
  feature.  If you'd like more information about the script, see the
  inline comments or check out the excellent webgl tutorial
  <a href="http://webglfundamentals.org/">webglfundamentals.org</a>
  to learn webgl basics.
  <pre><code class="  language-javascript">
var mat4 = require('gl-mat4');
var svs  = require('./vertex.c');
var sfs  = require('./fragment.c');

setup();

// Adds a canvas to the page and start rendering the scene
function setup() {
    var body     = document.getElementsByTagName('body')[0];
    var glCanvas = getCanvas(body);
    
    //create a simple renderer and a simple triangle
    var renderer = simpleRenderer(glCanvas.gl, 1, new Float32Array([-0.5,-0.5,-1.0,0.0,0.5,-1.0,0.5,-0.5,-1.0]));

    //Create a matrix to transform the triangle
    var matrix = mat4.create();
    //Move it back 4 units
    mat4.translate(matrix, matrix, [0.0, 0.0, -4.0]);

    //Called when a frame is scheduled.  A rapid sequence of scene draws creates the animation effect.
    var renderFn = function(timestamp) {
        mat4.rotateY(matrix, matrix, Math.PI/128);
        renderer(matrix, [1, 0, 1]);
        window.requestAnimationFrame(renderFn);
    }

    window.requestAnimationFrame(renderFn);

}

// Get A WebGL context
function getCanvas(parent) {
    //Create a canvas with specified attributes and append it to the parent.
    var canvas = document.createElement('canvas');
    canvas.setAttribute('id', 'glcanvas');
    canvas.setAttribute('width', '400');
    canvas.setAttribute('height', '400');
    parent.appendChild(canvas);
    
    var gl     = canvas.getContext('webgl');
    return {canvas: canvas, gl : gl}
}

//Returns a simple rendering function that draws the passed in vertices.
function simpleRenderer(gl, aspect, vertices) {

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, svs());
    gl.compileShader(vertexShader);
    
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, sfs());
    gl.compileShader(fragmentShader);
    
    var shaders = [vertexShader, fragmentShader];
    var program = gl.createProgram();
    shaders.forEach(function(shader) {
        gl.attachShader(program, shader);
    })
    gl.linkProgram(program);
    
    return function(parentNode, color) {
        gl.clear(gl.GL_COLOR_BUFFER_BIT);

        //Field of view is very similar to a cameras field of view.
        var fieldOfView = Math.PI/2;
        //Far edge of scene defines how far away an object can be from the camera before it disappears.
        var farEdgeOfScene = 100;
        //Near edge of scene defines how close an object can be from the camera before it disappears.
        var nearEdgeOfScene = 1;

        //Creates a perspective transformation from the above parameters.
        var perspective = mat4.perspective(mat4.create(), fieldOfView, aspect, nearEdgeOfScene, farEdgeOfScene);
        //Apply perspective to the parent transformation (translate + rotation)
        var projection = mat4.multiply(mat4.create(), perspective, parentNode);
        
        gl.useProgram(program);
        
        var matrixLocation = gl.getUniformLocation(program, "u_matrix");
    
        // Set the matrix.
        gl.uniformMatrix4fv(matrixLocation, false, projection);

        // set the color
        var colorLocation = gl.getUniformLocation(program, "u_color");
        gl.uniform4f(colorLocation, color[0], color[1], color[2], 1.0);
        
        // Create a buffer for the positions
        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        
        // look up where the vertex data needs to go.
        var positionLocation = gl.getAttribLocation(program, "a_position");
    
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.drawArrays(gl.TRIANGLES, 0, vertices.length/3);
    }

}
  </code></pre>

  <H3>fragment.c</H3>
  This simple fragment shader sets the color to a constant. u_color is populated by the javascript code above.
  <pre><code class="language-glsl">
precision mediump float;

uniform vec4 u_color;

void main() {

  gl_FragColor = u_color;

}
  </code></pre>

  <H3>vertex.c</H3>
  This vertex shader transforms the triangle vertices using a
  matrix.  The matrix is passed in on each render and defines
  transformations, mainly rotation, used to animate the triangle.
  <pre><code class="language-glsl">
attribute vec4 a_position;

uniform mat4 u_matrix;

void main() {
  gl_Position = u_matrix * a_position;
}
  </code></pre>

  <H3>Watchify</H3>
  <p>Run watchify to watch files and compile them into a single
  bundle.js javascript file.  Here the use of browserify-shader
  plugin allows the glsl shaders to be require'd into the
  script.  And --debug tells watchify to create a source map for managable source viewing/debugging</p>
  <pre><code class="language-bash">
 watchify --debug -t browserify-shader index.js -o bundle.js
  </code></pre>
 <H3>Result</H3>
  <p> Below is an animation using the bundle.js created with the above
    source files and watchify.</p>
  <script src="bundle.js"></script>
  <script src="3dify/bundle.js"></script>

  
  <table id="related"></table>
  
  <!-- Disqus Thread -->
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'sethlakowske'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  <!-- Google analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-30272910-1', 'auto');
    ga('send', 'pageview');
  </script>

</body>
</html>
  


